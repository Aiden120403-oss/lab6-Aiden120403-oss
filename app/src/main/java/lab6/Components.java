/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package lab6;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Scanner;
import java.util.Arrays;
import java.io.*;


public class Components {

    private static int vertex; // Adjacent list size
    private static LinkedList<Integer>[] ADJ; // Adjacent list
    static ArrayList<ArrayList<Integer>> AL = new ArrayList<ArrayList<Integer>>(vertex); // Adjacent list collision handler

    Components(int nodes) {
        vertex = nodes + 1;
        ADJ = new LinkedList[vertex];
        for (int i = 0; i < vertex; i++) {
            ADJ[i] = new LinkedList(); 
        }
    }

    public static void main(String[] args) {
        // This entire code only handles 2 single digit nodes, the assignment provided no specification 
        // on how many node or the size of the nodes
        File file = new File(args[0]); // get text file
        
        try {
            Scanner sc = new Scanner(file); // read input.txt

            String FirstLine = sc.nextLine(); // get number of nodes by reading first line

            int nodeNum = Integer.parseInt(FirstLine); // Convert node numers to integer value
            Components comp = new Components(nodeNum); // passs node size to constructor
            while(sc.hasNextLine()) { // traverse through scanner object
                String snake = sc.nextLine(); // convert 2 characters in returned string to add to AL
                char Node1 = snake.charAt(0);
                char Node2 = snake.charAt(1);
                int input1 = Integer.parseInt(String.valueOf(Node1));
                int input2 = Integer.parseInt(String.valueOf(Node2));
                BuildList(sc, input1, input2); // take integers to build adjacency list
            }
            DFS(); // depth-first search
            
            //print number of components
            System.out.println("Components of Graph: " + AL.size());
            

        }catch(FileNotFoundException e) {
            System.out.println("Error: File Note Found");
        }
        
    }
    
    public static void ALSearch(int NodeNum, ArrayList<Integer> AL, boolean[] visitedNode) {
        visitedNode[NodeNum] = true; // verify node is being currently visited
        AL.add(NodeNum); // build AL<> to keep track of data structure
        Iterator<Integer> traverser = ADJ[NodeNum].iterator(); // declare iterator for collision handling
 
        while (traverser.hasNext()) { // while iterator is not empty of elements in the column from the row in AL<>
            int n = traverser.next(); // assign which node the iterator is checking
            if (!visitedNode[n]) // keep checking the column until no availale nodes exist
                ALSearch(n, AL, visitedNode); // otherwise, while nodes are available, keep checking the column
        }
    }

    public static void DFS() {
        boolean[] visitedNode = new boolean[vertex]; // declare boolean[] to verify visited node
        for(int n = 0; n < vertex; n++) {  // visit each Array List (row) element in AL<> with snake <>
            ArrayList<Integer> snake = new ArrayList<Integer>(); // tempoaray array list to hold values for comparison
            if(!visitedNode[n]) { // while there are nodes to visit, move through array list
                ALSearch(n, snake, visitedNode);
                AL.add(snake);
            }
        }
    }
    
    public static void BuildList(Scanner sc, int input1, int input2) {
        // Build Adjacency List with linked list, undirected data structure
        ADJ[input1].add(input2); 
        ADJ[input2].add(input1);
    }
}